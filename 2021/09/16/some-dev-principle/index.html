<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 7.0.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="//fonts.googleapis.com/css?family=Noto Serif Simplified Chinese:300,300italic,400,400italic,700,700italic|Fira Code:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">
<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"colinger.github.io","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="开始对长期做业务开发的同学来说，写代码可能是件容易的事情，也可能是件很麻烦的事情。说容易，主要是因为需求基本上是CRUD(增、查、改、删)，再复杂的业务，也可以这么做(有点事务脚本的意思)来实现需求。说复杂或麻烦呢，主要是考虑如何分工，如果划分职责，把package分清楚，可能就是一件很繁琐和有挑战的事情。">
<meta property="og:type" content="article">
<meta property="og:title" content="如何把代码写的更好">
<meta property="og:url" content="http://colinger.github.io/2021/09/16/some-dev-principle/index.html">
<meta property="og:site_name" content="Colingo碎碎念">
<meta property="og:description" content="开始对长期做业务开发的同学来说，写代码可能是件容易的事情，也可能是件很麻烦的事情。说容易，主要是因为需求基本上是CRUD(增、查、改、删)，再复杂的业务，也可以这么做(有点事务脚本的意思)来实现需求。说复杂或麻烦呢，主要是考虑如何分工，如果划分职责，把package分清楚，可能就是一件很繁琐和有挑战的事情。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://colinger.github.io/2021/09/16/some-dev-principle/p1.png">
<meta property="og:image" content="http://colinger.github.io/2021/09/16/some-dev-principle/p2.png">
<meta property="og:image" content="http://colinger.github.io/2021/09/16/some-dev-principle/p4.png">
<meta property="og:image" content="http://colinger.github.io/2021/09/16/some-dev-principle/p5.png">
<meta property="og:image" content="http://colinger.github.io/2021/09/16/some-dev-principle/p6.png">
<meta property="og:image" content="http://colinger.github.io/2021/09/16/some-dev-principle/p7.png">
<meta property="og:image" content="http://colinger.github.io/2021/09/16/some-dev-principle/p11.png">
<meta property="og:image" content="http://colinger.github.io/2021/09/16/some-dev-principle/p12.png">
<meta property="og:image" content="http://colinger.github.io/2021/09/16/some-dev-principle/p9.png">
<meta property="og:image" content="http://colinger.github.io/2021/09/16/some-dev-principle/p10.png">
<meta property="article:published_time" content="2021-09-16T08:41:54.000Z">
<meta property="article:modified_time" content="2021-10-22T03:54:26.878Z">
<meta property="article:author" content="Colingo">
<meta property="article:tag" content="设计, 规范, 原则">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://colinger.github.io/2021/09/16/some-dev-principle/p1.png">

<link rel="canonical" href="http://colinger.github.io/2021/09/16/some-dev-principle/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>如何把代码写的更好 | Colingo碎碎念</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Colingo碎碎念</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">Programming language, 架构, 分布式, 微服务, iOS, Android</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://colinger.github.io/2021/09/16/some-dev-principle/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Colingo">
      <meta itemprop="description" content="一片自己我挑战的自留地">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Colingo碎碎念">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          如何把代码写的更好
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-09-16 16:41:54" itemprop="dateCreated datePublished" datetime="2021-09-16T16:41:54+08:00">2021-09-16</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-10-22 11:54:26" itemprop="dateModified" datetime="2021-10-22T11:54:26+08:00">2021-10-22</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h3 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h3><p>对长期做业务开发的同学来说，写代码可能是件容易的事情，也可能是件很麻烦的事情。说容易，主要是因为需求基本上是CRUD(增、查、改、删)，再复杂的业务，也可以这么做(有点<code>事务脚本</code>的意思)来实现需求。说复杂或麻烦呢，主要是考虑如何分工，如果划分职责，把package分清楚，可能就是一件很繁琐和有挑战的事情。</p>
<span id="more"></span>

<p>拿下单业务来说，假设我们在做一个checkout接口，需要做各种校验、查询商品信息、调用库存服务扣库存、然后生成订单：</p>
<img src="/2021/09/16/some-dev-principle/p1.png" width="80%" height="70%" alt="图片名称" align="center">

<p>常见写法，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CheckoutController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> ItemService itemService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> InventoryService inventoryService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> OrderRepository orderRepository;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping(&quot;checkout&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Result&lt;OrderDO&gt; <span class="title">checkout</span><span class="params">(Long itemId, Integer quantity)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1) Session管理</span></span><br><span class="line">        Long userId = SessionUtils.getLoggedInUserId();</span><br><span class="line">        <span class="keyword">if</span> (userId &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> Result.fail(<span class="string">&quot;Not Logged In&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 2）参数校验</span></span><br><span class="line">        <span class="keyword">if</span> (itemId &lt;= <span class="number">0</span> || quantity &lt;= <span class="number">0</span> || quantity &gt;= <span class="number">1000</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> Result.fail(<span class="string">&quot;Invalid Args&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3）外部数据补全</span></span><br><span class="line">        ItemDO item = itemService.getItem(itemId);</span><br><span class="line">        <span class="keyword">if</span> (item == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> Result.fail(<span class="string">&quot;Item Not Found&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4）调用外部服务</span></span><br><span class="line">        <span class="keyword">boolean</span> withholdSuccess = inventoryService.withhold(itemId, quantity);</span><br><span class="line">        <span class="keyword">if</span> (!withholdSuccess) &#123;</span><br><span class="line">            <span class="keyword">return</span> Result.fail(<span class="string">&quot;Inventory not enough&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      </span><br><span class="line">        <span class="comment">// 5）领域计算</span></span><br><span class="line">        Long cost = item.getPriceInCents() * quantity;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 6）领域对象操作</span></span><br><span class="line">        OrderDO order = <span class="keyword">new</span> OrderDO();</span><br><span class="line">        order.setItemId(itemId);</span><br><span class="line">        order.setBuyerId(userId);</span><br><span class="line">        order.setSellerId(item.getSellerId());</span><br><span class="line">        order.setCount(quantity);</span><br><span class="line">        order.setTotalCost(cost);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 7）数据持久化</span></span><br><span class="line">        orderRepository.createOrder(order);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 8）返回</span></span><br><span class="line">        <span class="keyword">return</span> Result.success(order);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为什么这种典型的流水账代码在实际应用中会有问题呢？其本质问题是违背了SRP（Single Responsbility Principle）单一职责原则。这段代码里混杂了<strong>业务计算</strong>、<strong>校验逻辑</strong>、<strong>基础设施</strong>、和<strong>通信协议</strong>等，在未来无论哪一部分的逻辑变更都会直接影响到这段代码，长期当后人不断的在上面叠加新的逻辑时，会造成代码复杂度增加、逻辑分支越来越多，最终造成bug或者没人敢重构的历史包袱。</p>
<p>面对这样的问题，如何处理？</p>
<p>主要的几个步骤分为：</p>
<ol>
<li><p>分离出独立的Interface接口层，负责处理网络协议相关的逻辑</p>
</li>
<li><p>从真实业务场景中，找出具体用例（Use Cases），然后将具体用例通过专用的Command指令、Query查询、和Event事件对象来承接</p>
</li>
<li><p>分离出独立的Application应用层，负责业务流程的编排，响应Command、Query和Event。每个应用层的方法应该代表整个业务流程中的一个节点</p>
</li>
</ol>
<h3 id="Interface接口层-Client"><a href="#Interface接口层-Client" class="headerlink" title="Interface接口层(Client)"></a>Interface接口层(Client)</h3><p>在实际做业务的过程中，特别是当支撑的上游业务比较多时，刻意去追求接口的统一通常会导致方法中的参数膨胀，或者导致方法的膨胀。举个例子：假设有一个宠物卡和一个亲子卡的业务公用一个开卡服务，但是宠物需要传入宠物类型，亲子的需要传入宝宝年龄。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 可以是RPC Provider 或者 Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">CardService</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 1）统一接口，参数膨胀</span></span><br><span class="line">    <span class="function">Result <span class="title">openCard</span><span class="params">(<span class="keyword">int</span> petType, <span class="keyword">int</span> babyAge)</span></span>;</span><br><span class="line">    <span class="comment">// 2）统一泛化接口，参数语意丢失</span></span><br><span class="line">    <span class="function">Result <span class="title">openCardV2</span><span class="params">(Map&lt;String, Object&gt; params)</span></span>;</span><br><span class="line">    <span class="comment">// 3）不泛化，同一个类里的接口膨胀</span></span><br><span class="line">    <span class="function">Result <span class="title">openPetCard</span><span class="params">(<span class="keyword">int</span> petType)</span></span>;</span><br><span class="line">    <span class="function">Result <span class="title">openBabyCard</span><span class="params">(<span class="keyword">int</span> babyAge)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看出来，无论是怎么操作，都有可能导致CardService这个服务未来越来越难以维护，方法越来越多，一个业务的变更有可能会导致整个服务/Controller的变更，最终变得无法维护</p>
<blockquote>
<p>一个Interface层的类应该是“小而美”的，应该是面向“一个单一的业务”或“一类同样需求的业务”，需要尽量避免用同一个类承接不同类型业务的需求</p>
</blockquote>
<p>基于上面的这个规范，可以发现宠物卡和亲子卡虽然看起来像是类似的需求，但并非是“同样需求”的，可以预见到在未来的某个时刻，这两个业务的需求和需要提供的接口会越走越远，所以需要将这两个接口类拆分开：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">PetCardService</span> </span>&#123;</span><br><span class="line">    <span class="function">Result <span class="title">openPetCard</span><span class="params">(<span class="keyword">int</span> petType)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BabyCardService</span> </span>&#123;</span><br><span class="line">    <span class="function">Result <span class="title">openBabyCard</span><span class="params">(<span class="keyword">int</span> babyAge)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>好处是符合了Single Responsibility Principle单一职责原则，也就是说一个接口类仅仅会因为一个（或一类）业务的变化而变化。建议当一个现有的接口类过度膨胀时，可以考虑对接口类做拆分，<br>拆分原则和SRP一致。</p>
<p>如果按照这种做法，会不会产生大量的接口类，导致代码逻辑重复？答案是不会，因为在DDD分层架构里，接口类的核心作用仅仅是协议层，每类业务的协议可以是不同的，而真实的业务逻辑会沉淀到应用层。也就是说Interface和Application的关系是多对多的：</p>
<img src="/2021/09/16/some-dev-principle/p2.png" width="60%" height="70%" alt="图片名称" align="center">

<p>总结interface(Client)：</p>
<ol>
<li><p>职责：主要负责承接网络协议的转化、Session管理等</p>
</li>
<li><p>接口数量：避免所谓的统一API，不必人为限制接口类的数量，每个/每类业务对应一套接口即可，接口参数应该符合业务需求，避免大而全的入参</p>
</li>
<li><p>接口出参：统一返回Result</p>
</li>
<li><p>异常处理：应该捕捉所有异常，避免异常信息的泄漏。可以通过AOP统一处理，避免代码里有大量重复代码。</p>
</li>
</ol>
<h3 id="Application层-App"><a href="#Application层-App" class="headerlink" title="Application层(App)"></a>Application层(App)</h3><h4 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h4><p>Application层的几个核心类：</p>
<ul>
<li><p>ApplicationService应用服务：最核心的类，负责业务流程的编排，但本身不负责任何业务逻辑</p>
</li>
<li><p>DTO Assembler：负责将内部领域模型转化为可对外的DTO</p>
</li>
<li><p>Command、Query、Event对象：作为ApplicationService的入参</p>
</li>
<li><p>返回的DTO：作为ApplicationService的出参</p>
</li>
</ul>
<p>Application层最核心的对象是ApplicationService，它的核心功能是承接“业务流程“。但是在讲ApplicationService的规范之前，要先重点的讲几个特殊类型的对象，即Command、Query和Event。</p>
<h4 id="CEQ"><a href="#CEQ" class="headerlink" title="CEQ"></a>CEQ</h4><p>从本质上来看，这几种对象都是Value Object，但是从语义上来看有比较大的差异：</p>
<ul>
<li><p><strong>C</strong>ommand指令：指调用方明确想让系统操作的指令，其预期是对一个系统有影响，也就是写操作。通常来讲指令需要有一个明确的返回值（如同步的操作结果，或异步的指令已经被接受）。</p>
</li>
<li><p><strong>Q</strong>uery查询：指调用方明确想查询的东西，包括查询参数、过滤、分页等条件，其预期是对一个系统的数据完全不影响的，也就是只读操作。</p>
</li>
<li><p><strong>E</strong>vent事件：指一件已经发生过的既有事实，需要系统根据这个事实作出改变或者响应的，通常事件处理都会有一定的写操作。事件处理器不会有返回值。这里需要注意一下的是，Application层的Event概念和Domain层的DomainEvent是类似的概念，但不一定是同一回事，这里的Event更多是外部一种通知机制而已。</p>
</li>
</ul>
<p>总结一下：</p>
<table>
<thead>
<tr>
<th></th>
<th>Command</th>
<th align="left">Query</th>
<th>Event</th>
</tr>
</thead>
<tbody><tr>
<td>语意</td>
<td>“希望”能触发的操作</td>
<td align="left">各种条件查询</td>
<td>已经发生的事情</td>
</tr>
<tr>
<td>读/写</td>
<td>写</td>
<td align="left">只读</td>
<td>一般是写</td>
</tr>
<tr>
<td>返回值</td>
<td>DTO或Boolean</td>
<td align="left">DTO或Collection</td>
<td>Void</td>
</tr>
</tbody></table>
<h5 id="为什么要用CQE对象？"><a href="#为什么要用CQE对象？" class="headerlink" title="为什么要用CQE对象？"></a>为什么要用CQE对象？</h5><p>通常在很多代码里，能看到接口上有多个参数，比如上文中的案例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Result&lt;OrderDO&gt; <span class="title">checkout</span><span class="params">(Long itemId, Integer quantity)</span></span>;</span><br></pre></td></tr></table></figure>

<p>如果需要在接口上增加参数，考虑到向前兼容，则需要增加一个方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Result&lt;OrderDO&gt; <span class="title">checkout</span><span class="params">(Long itemId, Integer quantity)</span></span>;</span><br><span class="line"><span class="function">Result&lt;OrderDO&gt; <span class="title">checkout</span><span class="params">(Long itemId, Integer quantity, Integer channel)</span></span>;</span><br></pre></td></tr></table></figure>

<p>或者常见的查询方法，由于条件的不同导致多个方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">List&lt;OrderDO&gt; <span class="title">queryByItemId</span><span class="params">(Long itemId)</span></span>;</span><br><span class="line"><span class="function">List&lt;OrderDO&gt; <span class="title">queryBySellerId</span><span class="params">(Long sellerId)</span></span>;</span><br><span class="line"><span class="function">List&lt;OrderDO&gt; <span class="title">queryBySellerIdWithPage</span><span class="params">(Long sellerId, <span class="keyword">int</span> currentPage, <span class="keyword">int</span> pageSize)</span></span>;</span><br></pre></td></tr></table></figure>

<p>可以看出来，传统的接口写法有几个问题：</p>
<ol>
<li><p>接口膨胀：一个查询条件一个方法</p>
</li>
<li><p>难以扩展：每新增一个参数都有可能需要调用方升级</p>
</li>
<li><p>难以测试：接口一多，职责随之变得繁杂，业务场景各异，测试用例难以维护</p>
</li>
</ol>
<p>还有另外一个最重要的问题是：这种类型的参数罗列，本身没有任何业务上的”语意“，只是一堆参数而已，无法明确的表达出来意图。</p>
<h5 id="CQE规范"><a href="#CQE规范" class="headerlink" title="CQE规范"></a>CQE规范</h5><p>在Application层的接口里，强力建议的一个规范是：</p>
<blockquote>
<p>规范：ApplicationService的接口入参只能是一个Command、Query或Event对象，CQE对象需要能代表当前方法的语意。唯一可以的例外是根据单一ID查询的情况，可以省略掉一个Query对象的创建</p>
</blockquote>
<p>按照上面的规范，实现案例是：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">CheckoutService</span> </span>&#123;</span><br><span class="line">    <span class="function">OrderDTO <span class="title">checkout</span><span class="params">(<span class="meta">@Valid</span> CheckoutCommand cmd)</span></span>;</span><br><span class="line">    <span class="function">List&lt;OrderDTO&gt; <span class="title">query</span><span class="params">(OrderQuery query)</span></span>;</span><br><span class="line">    <span class="function">OrderDTO <span class="title">getOrder</span><span class="params">(Long orderId)</span></span>; <span class="comment">// 注意单一ID查询可以不用Query</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CheckoutCommand</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Long userId;</span><br><span class="line">    <span class="keyword">private</span> Long itemId;</span><br><span class="line">    <span class="keyword">private</span> Integer quantity;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderQuery</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Long sellerId;</span><br><span class="line">    <span class="keyword">private</span> Long itemId;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> currentPage;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> pageSize;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个规范的好处是：提升了接口的稳定性、降低低级的重复，并且让接口入参更加语意化。</p>
<h5 id="CQE-vs-DTO"><a href="#CQE-vs-DTO" class="headerlink" title="CQE vs DTO"></a>CQE vs DTO</h5><p>从上面的代码能看出来，ApplicationService的入参是CQE对象，但是出参却是一个DTO，从代码格式上来看都是简单的POJO对象，那么他们之间有什么区别呢？</p>
<ul>
<li>CQE：CQE对象是ApplicationService的输入，是有明确的”意图“的，所以这个对象必须保证其“正确性”。</li>
<li>DTO：DTO对象只是数据容器，只是为了和外部交互，所以本身不包含任何逻辑，只是贫血对象。</li>
</ul>
<p>但可能最重要的一点：因为CQE是“意图”，所以CQE对象在理论上可以有“无限”个，每个代表不同的意图；但是DTO作为模型数据容器，和模型一一对应，所以是有限的。</p>
<h5 id="CEQ验证"><a href="#CEQ验证" class="headerlink" title="CEQ验证"></a>CEQ验证</h5><p>CQE作为ApplicationService的输入，必须保证其正确性，那么这个校验是放在哪里呢？</p>
<p>在最早的代码里，曾经有这样的校验逻辑，当时写在了服务里：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (itemId &lt;= <span class="number">0</span> || quantity &lt;= <span class="number">0</span> || quantity &gt;= <span class="number">1000</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> Result.fail(<span class="string">&quot;Invalid Args&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种代码在日常非常常见，但其最大的问题就是大量的非业务代码混杂在业务代码中，很明显的违背了单一职责原则。但因为当时入参仅仅是简单的int，所以这个逻辑只能出现在服务里。现在当入参改为了CQE之后，我们可以利用java标准JSR303或JSR380的Bean Validation来前置这个校验逻辑。</p>
<blockquote>
<p>规范：CQE对象的校验应该前置，避免在ApplicationService里做参数的校验。可以通过JSR303/380和Spring Validation来实现 </p>
</blockquote>
<p>前面的例子可以改造为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Validated</span> <span class="comment">// Spring的注解</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CheckoutServiceImpl</span> <span class="keyword">implements</span> <span class="title">CheckoutService</span> </span>&#123;</span><br><span class="line">    <span class="function">OrderDTO <span class="title">checkout</span><span class="params">(<span class="meta">@Valid</span> CheckoutCommand cmd)</span> </span>&#123; <span class="comment">// 这里@Valid是JSR-303/380的注解</span></span><br><span class="line">        <span class="comment">// 如果校验失败会抛异常，在interface层被捕捉</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CheckoutCommand</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@NotNull(message = &quot;用户未登陆&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Long userId;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@NotNull</span></span><br><span class="line">    <span class="meta">@Positive(message = &quot;需要是合法的itemId&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Long itemId;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@NotNull</span></span><br><span class="line">    <span class="meta">@Min(value = 1, message = &quot;最少1件&quot;)</span></span><br><span class="line">    <span class="meta">@Max(value = 1000, message = &quot;最多不能超过1000件&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Integer quantity;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种做法的好处是，让ApplicationService更加清爽，同时各种错误信息可以通过Bean Validation的API做各种个性化定制。</p>
<h5 id="避免复用CQE"><a href="#避免复用CQE" class="headerlink" title="避免复用CQE"></a>避免复用CQE</h5><p>因为CQE是有“意图”和“语意”的，我们需要尽量避免CQE对象的复用，哪怕所有的参数都一样，只要他们的语意不同，尽量还是要用不同的对象。</p>
<h4 id="ApplicationService"><a href="#ApplicationService" class="headerlink" title="ApplicationService"></a>ApplicationService</h4><p>ApplicationService负责了业务流程的编排，是将原有业务流水账代码剥离了校验逻辑、领域计算、持久化等逻辑之后剩余的流程，是“胶水层”代码。</p>
<p>参考一个简易的交易流程：</p>
<img src="/2021/09/16/some-dev-principle/p4.png" width="80%" height="70%" alt="图片名称" align="center">

<p>在这个案例里可以看出，交易这个领域一共有5个用例：下单、支付成功、支付失败关单、物流信息更新、关闭订单。这5个用例可以用5个Command/Event对象代替，也就是对应了5个方法。</p>
<h5 id="三种ApplicationService常见的组织形态-Bad-Case-："><a href="#三种ApplicationService常见的组织形态-Bad-Case-：" class="headerlink" title="三种ApplicationService常见的组织形态(Bad Case)："></a>三种ApplicationService常见的组织形态(Bad Case)：</h5><p>1.复杂的业务流程会导致一个类的方法过多，有可能代码量过大</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">CheckoutService</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 下单</span></span><br><span class="line">    <span class="function">OrderDTO <span class="title">checkout</span><span class="params">(<span class="meta">@Valid</span> CheckoutCommand cmd)</span></span>;</span><br><span class="line">    <span class="comment">// 支付成功</span></span><br><span class="line">    <span class="function">OrderDTO <span class="title">payReceived</span><span class="params">(<span class="meta">@Valid</span> PaymentReceivedEvent event)</span></span>;</span><br><span class="line">    <span class="comment">// 支付取消</span></span><br><span class="line">    <span class="function">OrderDTO <span class="title">payCanceled</span><span class="params">(<span class="meta">@Valid</span> PaymentCanceledEvent event)</span></span>;</span><br><span class="line">    <span class="comment">// 发货</span></span><br><span class="line">    <span class="function">OrderDTO <span class="title">packageSent</span><span class="params">(<span class="meta">@Valid</span> PackageSentEvent event)</span></span>;</span><br><span class="line">    <span class="comment">// 收货</span></span><br><span class="line">    <span class="function">OrderDTO <span class="title">delivered</span><span class="params">(<span class="meta">@Valid</span> DeliveredEvent event)</span></span>;</span><br><span class="line">    <span class="comment">// 批量查询</span></span><br><span class="line">    <span class="function">List&lt;OrderDTO&gt; <span class="title">query</span><span class="params">(OrderQuery query)</span></span>;</span><br><span class="line">    <span class="comment">// 单个查询</span></span><br><span class="line">    <span class="function">OrderDTO <span class="title">getOrder</span><span class="params">(Long orderId)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2.化整为零：通过增加独立的CommandHandler、EventHandler来降低一个类中的代码量：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CheckoutCommandHandler</span> <span class="keyword">implements</span> <span class="title">CommandHandler</span>&lt;<span class="title">CheckoutCommand</span>, <span class="title">OrderDTO</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> OrderDTO <span class="title">handle</span><span class="params">(CheckoutCommand cmd)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CheckoutServiceImpl</span> <span class="keyword">implements</span> <span class="title">CheckoutService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> CheckoutCommandHandler checkoutCommandHandler;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> OrderDTO <span class="title">checkout</span><span class="params">(<span class="meta">@Valid</span> CheckoutCommand cmd)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> checkoutCommandHandler.handle(cmd);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3.事件总线：通过CommandBus、EventBus，直接将指令或事件抛给对应的Handler，EventBus比较常见</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在这里框架通常可以根据接口识别到这个负责处理PaymentReceivedEvent</span></span><br><span class="line"><span class="comment">// 也可以通过增加注解识别</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PaymentReceivedHandler</span> <span class="keyword">implements</span> <span class="title">EventHandler</span>&lt;<span class="title">PaymentReceivedEvent</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(PaymentReceivedEvent event)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Interface层，这个是RocketMQ的Listener</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderMessageListener</span> <span class="keyword">implements</span> <span class="title">MessageListenerOrderly</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> EventBus eventBus;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ConsumeOrderlyStatus <span class="title">consumeMessage</span><span class="params">(List&lt;MessageExt&gt; msgs, ConsumeOrderlyContext context)</span> </span>&#123;</span><br><span class="line">       </span><br><span class="line">        PaymentReceivedEvent event = <span class="keyword">new</span> PaymentReceivedEvent();</span><br><span class="line">        eventBus.dispatch(event); <span class="comment">// 不需要指定消费</span></span><br><span class="line">        <span class="keyword">return</span> ConsumeOrderlyStatus.SUCCESS;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种做法可以实现Interface层和某个具体的ApplicationService或Handler的完全静态解耦，在运行时动态dispatch，做的比较好的框架如AxonFramework。虽然看起来很便利，但是根据我们自己业务的实践和踩坑发现，当代码中的CQE对象越来越多，handler越来越复杂时，运行时的dispatch缺乏了静态代码间的关联关系，导致代码很难读懂，特别是当你需要trace一个复杂调用链路时，因为dispatch是运行时的，很难摸清楚具体调用到的对象。现在已经不建议这么做了。</p>
<h5 id="Application-Service-是业务流程的封装，不处理业务逻辑"><a href="#Application-Service-是业务流程的封装，不处理业务逻辑" class="headerlink" title="Application Service 是业务流程的封装，不处理业务逻辑"></a>Application Service 是业务流程的封装，不处理业务逻辑</h5><p>虽然之前曾经无数次重复ApplicationService只负责业务流程串联，不负责业务逻辑，但如何判断一段代码到底是业务流程还是逻辑呢？举个之前的例子，最初的代码重构后：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@Validated</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CheckoutServiceImpl</span> <span class="keyword">implements</span> <span class="title">CheckoutService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> OrderDtoAssembler orderDtoAssembler = OrderDtoAssembler.INSTANCE;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> ItemService itemService;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> InventoryService inventoryService;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> OrderRepository orderRepository;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> OrderDTO <span class="title">checkout</span><span class="params">(<span class="meta">@Valid</span> CheckoutCommand cmd)</span> </span>&#123;</span><br><span class="line">        ItemDO item = itemService.getItem(cmd.getItemId());</span><br><span class="line">        <span class="keyword">if</span> (item == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Item not found&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span> withholdSuccess = inventoryService.withhold(cmd.getItemId(), cmd.getQuantity());</span><br><span class="line">        <span class="keyword">if</span> (!withholdSuccess) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Inventory not enough&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Order order = <span class="keyword">new</span> Order();</span><br><span class="line">        order.setBuyerId(cmd.getUserId());</span><br><span class="line">        order.setSellerId(item.getSellerId());</span><br><span class="line">        order.setItemId(item.getItemId());</span><br><span class="line">        order.setItemTitle(item.getTitle());</span><br><span class="line">        order.setItemUnitPrice(item.getPriceInCents());</span><br><span class="line">        order.setCount(cmd.getQuantity());</span><br><span class="line"></span><br><span class="line">        Order savedOrder = orderRepository.save(order);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> orderDtoAssembler.orderToDTO(savedOrder);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>判断是否业务流程的几个点：</p>
<ol>
<li><p>不要有if/else分支逻辑：也就是说代码的Cyclomatic Complexity（循环复杂度）应该尽量等于1</p>
<p>通常有分支逻辑的，都代表一些业务判断，应该将逻辑封装到DomainService或者Entity里。但这不代表完全不能有if逻辑，比如，在这段代码里：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">boolean</span> withholdSuccess = inventoryService.withhold(cmd.getItemId(), cmd.getQuantity());</span><br><span class="line"><span class="keyword">if</span> (!withholdSuccess) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Inventory not enough&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>虽然CC &gt; 1，但是仅仅代表了中断条件，具体的业务逻辑处理并没有受影响。可以把它看作为Precondition。</p>
</li>
<li><p>不要有任何计算<br>在最早的代码里有这个计算：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 5）领域计算</span></span><br><span class="line">Long cost = item.getPriceInCents() * quantity;</span><br><span class="line">order.setTotalCost(cost);</span><br></pre></td></tr></table></figure>

<p>通过将这个计算逻辑封装到实体里，避免在ApplicationService里做计算</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Order</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Long itemUnitPrice;</span><br><span class="line">    <span class="keyword">private</span> Integer count;</span><br><span class="line">    <span class="comment">// 把原来一个在ApplicationService的计算迁移到Entity里</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Long <span class="title">getTotalCost</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> itemUnitPrice * count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">order.setItemUnitPrice(item.getPriceInCents());</span><br><span class="line">order.setCount(cmd.getQuantity());</span><br></pre></td></tr></table></figure>
</li>
<li><p>一些数据的转化可以交给其他对象来做</p>
</li>
</ol>
<p>比如DTO Assembler，将对象间转化的逻辑沉淀在单独的类中，降低ApplicationService的复杂度</p>
<p>OrderDTO dto = orderDtoAssembler.orderToDTO(savedOrder);</p>
<p>常用的ApplicationService“套路”</p>
<ul>
<li><p>准备数据：包括从外部服务或持久化源取出相对应的Entity、VO以及外部服务返回的DTO。</p>
</li>
<li><p>执行操作：包括新对象的创建、赋值，以及调用领域对象的方法对其进行操作。需要注意的是这个时候通常都是纯内存操作，非持久化。</p>
</li>
<li><p>持久化：将操作结果持久化，或操作外部系统产生相应的影响，包括发消息等异步操作。</p>
</li>
</ul>
<h4 id="DTO-Assembler-一般用MapStruct"><a href="#DTO-Assembler-一般用MapStruct" class="headerlink" title="DTO Assembler(一般用MapStruct)"></a>DTO Assembler(一般用MapStruct)</h4><p>一个经常被忽视的问题是 ApplicationService应该返回 Entity 还是 DTO？这里提出一个规范，在DDD分层架构中：</p>
<p>ApplicationService应该永远返回DTO而不是Entity  </p>
<p>为什么呢？</p>
<ol>
<li><p>构建领域边界：ApplicationService的入参是CQE对象，出参是DTO，这些基本上都属于简单的POJO，来确保Application层的内外互相不影响。</p>
</li>
<li><p>降低规则依赖：Entity里面通常会包含业务规则，如果ApplicationService返回Entity，则会导致调用方直接依赖业务规则。如果内部规则变更可能直接影响到外部。</p>
</li>
<li><p>通过DTO组合降低成本：Entity是有限的，DTO可以是多个Entity、VO的自由组合，一次性封装成复杂DTO，或者有选择的抽取部分参数封装成DTO可以降低对外的成本。</p>
</li>
</ol>
<p>结合之前的Data Mapper，DTO、Entity和DataObject之间的关系如下图：</p>
<img src="/2021/09/16/some-dev-principle/p5.png" width="80%" height="70%" alt="图片名称" align="center">

<p>总结：</p>
<ul>
<li><p>入参：具像化Command、Query、Event对象作为ApplicationService的入参，唯一可以的例外是单ID查询的场景。</p>
</li>
<li><p>CQE的语意化：CQE对象有语意，不同用例之间语意不同，即使参数一样也要避免复用。</p>
</li>
<li><p>入参校验：基础校验通过Bean Validation api解决。Spring Validation自带Validation的AOP，也可以自己写AOP。</p>
</li>
<li><p>出参：统一返回DTO，而不是Entity或DO。</p>
</li>
<li><p>DTO转化：用DTO Assembler负责Entity/VO到DTO的转化。</p>
</li>
<li><p>异常处理：不统一捕捉异常，可以随意抛异常。</p>
</li>
</ul>
<h4 id="Anti-Corruption-Layer防腐层"><a href="#Anti-Corruption-Layer防腐层" class="headerlink" title="Anti-Corruption Layer防腐层"></a>Anti-Corruption Layer防腐层</h4><p>ACL防腐层的简单原理如下：</p>
<ul>
<li><p>对于依赖的外部对象，我们抽取出所需要的字段，生成一个内部所需的VO或DTO类</p>
</li>
<li><p>构建一个新的Facade，在Facade中封装调用链路，将外部类转化为内部类</p>
</li>
<li><p>针对外部系统调用，同样的用Facade方法封装外部调用链路</p>
</li>
</ul>
<p>无防腐层的情况：</p>
<img src="/2021/09/16/some-dev-principle/p6.png" width="80%" height="70%" alt="图片名称" align="center">

<p>有防腐层的情况：</p>
<img src="/2021/09/16/some-dev-principle/p7.png" width="80%" height="70%" alt="图片名称" align="center">

<h3 id="项目组织结构"><a href="#项目组织结构" class="headerlink" title="项目组织结构"></a>项目组织结构</h3><h4 id="三层架构"><a href="#三层架构" class="headerlink" title="三层架构"></a>三层架构</h4><h5 id="主要特点"><a href="#主要特点" class="headerlink" title="主要特点"></a>主要特点</h5><ol>
<li>方便</li>
<li>灵活</li>
<li>上手快(“效率高”)</li>
</ol>
<h5 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h5><img src="/2021/09/16/some-dev-principle/p11.png" width="30%" height="70%" alt="图片名称" align="center">

<h5 id="项目结构"><a href="#项目结构" class="headerlink" title="项目结构"></a>项目结构</h5><img src="/2021/09/16/some-dev-principle/p12.png" width="30%" height="70%" alt="图片名称" align="center">

<h4 id="六边形架构"><a href="#六边形架构" class="headerlink" title="六边形架构"></a>六边形架构</h4><h5 id="主要特点-1"><a href="#主要特点-1" class="headerlink" title="主要特点"></a>主要特点</h5><ol>
<li>业务内聚</li>
<li>依赖倒置</li>
<li>面向接口</li>
</ol>
<h5 id="架构-1"><a href="#架构-1" class="headerlink" title="架构"></a>架构</h5><img src="/2021/09/16/some-dev-principle/p9.png" width="80%" height="70%" alt="图片名称" align="center">

<h5 id="项目结构-1"><a href="#项目结构-1" class="headerlink" title="项目结构"></a>项目结构</h5><img src="/2021/09/16/some-dev-principle/p10.png" width="50%" height="70%" alt="图片名称" align="center">

<h4 id="适合自己的"><a href="#适合自己的" class="headerlink" title="适合自己的"></a>适合自己的</h4><p>根据业务场景(大环境，小环境)，个性化适合业务领域的结构！</p>
<h3 id="错误码"><a href="#错误码" class="headerlink" title="错误码"></a>错误码</h3><p>B1234567890；E1234567890</p>
<h4 id="为什么要有错误码？"><a href="#为什么要有错误码？" class="headerlink" title="为什么要有错误码？"></a>为什么要有错误码？</h4><blockquote>
<p>谁的错？错在哪？</p>
</blockquote>
<ol>
<li><p>降低沟通成本</p>
</li>
<li><p>快速定位问题</p>
</li>
</ol>
<h4 id="如何设计"><a href="#如何设计" class="headerlink" title="如何设计"></a>如何设计</h4><h5 id="HTTP的响应码"><a href="#HTTP的响应码" class="headerlink" title="HTTP的响应码"></a>HTTP的响应码</h5><ul>
<li>200 - 请求成功</li>
<li>301 - 资源（网页等）被永久转移到其它URL</li>
<li>404 - 请求的资源（网页等）不存在</li>
<li>500 - 内部服务器错误</li>
</ul>
<table>
<thead>
<tr>
<th>分类</th>
<th>分类描述</th>
</tr>
</thead>
<tbody><tr>
<td>1**</td>
<td>信息，服务器收到请求，需要请求者继续执行操作</td>
</tr>
<tr>
<td>2**</td>
<td>成功，操作被成功接收并处理</td>
</tr>
<tr>
<td>3**</td>
<td>重定向，需要进一步的操作以完成请求</td>
</tr>
<tr>
<td>4**</td>
<td>客户端错误，请求包含语法错误或无法完成请求</td>
</tr>
<tr>
<td>5**</td>
<td>服务器错误，服务器在处理请求的过程中发生了错误</td>
</tr>
</tbody></table>
<h5 id="腾讯小程序"><a href="#腾讯小程序" class="headerlink" title="腾讯小程序"></a>腾讯小程序</h5><table>
<thead>
<tr>
<th>错误代码</th>
<th>描述</th>
<th>原因</th>
<th>解决方案</th>
</tr>
</thead>
<tbody><tr>
<td>NO_AUTH</td>
<td>没有该接口权限</td>
<td>1. 用户账号被冻结，无法付款</td>
<td>请根据具体的错误返回描述做对应处理，如返回描述不够明确，请参考此处的错误原因做排查。</td>
</tr>
<tr>
<td>AMOUNT_LIMIT</td>
<td>金额超限</td>
<td>1. 被微信风控拦截，最低单笔付款限额调整为5元。</td>
<td>目前最低付款金额为1元，最高10万元，请确认是否付款金额超限。</td>
</tr>
</tbody></table>
<h5 id="Twitter-Facebook"><a href="#Twitter-Facebook" class="headerlink" title="Twitter/Facebook"></a>Twitter/Facebook</h5><table>
<thead>
<tr>
<th>错误码</th>
<th>类型</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>192</td>
<td>OAuthException</td>
<td>Missing redirect_uri parameter.</td>
</tr>
<tr>
<td>215</td>
<td></td>
<td>Bad Authentication data</td>
</tr>
</tbody></table>
<h5 id="项目性质"><a href="#项目性质" class="headerlink" title="项目性质"></a>项目性质</h5><p>内部使用，私有，公有</p>
<p>PM的设计，研发同学的想法。 </p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>不忘初衷！</p>
<blockquote>
<p>快速溯源、简单易记、沟通标准化</p>
</blockquote>
<h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p>虽说编写代码是个非常有趣的过程，但要写出有灵魂的代码也需要一些指导思想，比如SOLID原则：</p>
<ol>
<li>SRP(单一职责原则)</li>
<li>OCP(开闭原则)</li>
<li>LSP(里氏替换原则)</li>
<li>ISP(接口隔离原则)</li>
<li>DIP(依赖反转原则)</li>
</ol>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E8%AE%BE%E8%AE%A1-%E8%A7%84%E8%8C%83-%E5%8E%9F%E5%88%99/" rel="tag"># 设计, 规范, 原则</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2021/06/25/cons-protocol/" rel="prev" title="一致性算法">
      <i class="fa fa-chevron-left"></i> 一致性算法
    </a></div>
      <div class="post-nav-item">
    <a href="/2021/11/30/the-log/" rel="next" title="软件工程师都应该知道的实时数据抽象：日志-1">
      软件工程师都应该知道的实时数据抽象：日志-1 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BC%80%E5%A7%8B"><span class="nav-number">1.</span> <span class="nav-text">开始</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Interface%E6%8E%A5%E5%8F%A3%E5%B1%82-Client"><span class="nav-number">2.</span> <span class="nav-text">Interface接口层(Client)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Application%E5%B1%82-App"><span class="nav-number">3.</span> <span class="nav-text">Application层(App)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BB%84%E6%88%90"><span class="nav-number">3.1.</span> <span class="nav-text">组成</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#CEQ"><span class="nav-number">3.2.</span> <span class="nav-text">CEQ</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E7%94%A8CQE%E5%AF%B9%E8%B1%A1%EF%BC%9F"><span class="nav-number">3.2.1.</span> <span class="nav-text">为什么要用CQE对象？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#CQE%E8%A7%84%E8%8C%83"><span class="nav-number">3.2.2.</span> <span class="nav-text">CQE规范</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#CQE-vs-DTO"><span class="nav-number">3.2.3.</span> <span class="nav-text">CQE vs DTO</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#CEQ%E9%AA%8C%E8%AF%81"><span class="nav-number">3.2.4.</span> <span class="nav-text">CEQ验证</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%81%BF%E5%85%8D%E5%A4%8D%E7%94%A8CQE"><span class="nav-number">3.2.5.</span> <span class="nav-text">避免复用CQE</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ApplicationService"><span class="nav-number">3.3.</span> <span class="nav-text">ApplicationService</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%B8%89%E7%A7%8DApplicationService%E5%B8%B8%E8%A7%81%E7%9A%84%E7%BB%84%E7%BB%87%E5%BD%A2%E6%80%81-Bad-Case-%EF%BC%9A"><span class="nav-number">3.3.1.</span> <span class="nav-text">三种ApplicationService常见的组织形态(Bad Case)：</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Application-Service-%E6%98%AF%E4%B8%9A%E5%8A%A1%E6%B5%81%E7%A8%8B%E7%9A%84%E5%B0%81%E8%A3%85%EF%BC%8C%E4%B8%8D%E5%A4%84%E7%90%86%E4%B8%9A%E5%8A%A1%E9%80%BB%E8%BE%91"><span class="nav-number">3.3.2.</span> <span class="nav-text">Application Service 是业务流程的封装，不处理业务逻辑</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#DTO-Assembler-%E4%B8%80%E8%88%AC%E7%94%A8MapStruct"><span class="nav-number">3.4.</span> <span class="nav-text">DTO Assembler(一般用MapStruct)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Anti-Corruption-Layer%E9%98%B2%E8%85%90%E5%B1%82"><span class="nav-number">3.5.</span> <span class="nav-text">Anti-Corruption Layer防腐层</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A1%B9%E7%9B%AE%E7%BB%84%E7%BB%87%E7%BB%93%E6%9E%84"><span class="nav-number">4.</span> <span class="nav-text">项目组织结构</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%89%E5%B1%82%E6%9E%B6%E6%9E%84"><span class="nav-number">4.1.</span> <span class="nav-text">三层架构</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%B8%BB%E8%A6%81%E7%89%B9%E7%82%B9"><span class="nav-number">4.1.1.</span> <span class="nav-text">主要特点</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%9E%B6%E6%9E%84"><span class="nav-number">4.1.2.</span> <span class="nav-text">架构</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%A1%B9%E7%9B%AE%E7%BB%93%E6%9E%84"><span class="nav-number">4.1.3.</span> <span class="nav-text">项目结构</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%85%AD%E8%BE%B9%E5%BD%A2%E6%9E%B6%E6%9E%84"><span class="nav-number">4.2.</span> <span class="nav-text">六边形架构</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%B8%BB%E8%A6%81%E7%89%B9%E7%82%B9-1"><span class="nav-number">4.2.1.</span> <span class="nav-text">主要特点</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%9E%B6%E6%9E%84-1"><span class="nav-number">4.2.2.</span> <span class="nav-text">架构</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%A1%B9%E7%9B%AE%E7%BB%93%E6%9E%84-1"><span class="nav-number">4.2.3.</span> <span class="nav-text">项目结构</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%80%82%E5%90%88%E8%87%AA%E5%B7%B1%E7%9A%84"><span class="nav-number">4.3.</span> <span class="nav-text">适合自己的</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%94%99%E8%AF%AF%E7%A0%81"><span class="nav-number">5.</span> <span class="nav-text">错误码</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E6%9C%89%E9%94%99%E8%AF%AF%E7%A0%81%EF%BC%9F"><span class="nav-number">5.1.</span> <span class="nav-text">为什么要有错误码？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1"><span class="nav-number">5.2.</span> <span class="nav-text">如何设计</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#HTTP%E7%9A%84%E5%93%8D%E5%BA%94%E7%A0%81"><span class="nav-number">5.2.1.</span> <span class="nav-text">HTTP的响应码</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%85%BE%E8%AE%AF%E5%B0%8F%E7%A8%8B%E5%BA%8F"><span class="nav-number">5.2.2.</span> <span class="nav-text">腾讯小程序</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Twitter-Facebook"><span class="nav-number">5.2.3.</span> <span class="nav-text">Twitter&#x2F;Facebook</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%A1%B9%E7%9B%AE%E6%80%A7%E8%B4%A8"><span class="nav-number">5.2.4.</span> <span class="nav-text">项目性质</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%80%BB%E7%BB%93"><span class="nav-number">5.3.</span> <span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9C%80%E5%90%8E"><span class="nav-number">6.</span> <span class="nav-text">最后</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Colingo</p>
  <div class="site-description" itemprop="description">一片自己我挑战的自留地</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">16</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
        <span class="site-state-item-count">9</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">17</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Colingo</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
